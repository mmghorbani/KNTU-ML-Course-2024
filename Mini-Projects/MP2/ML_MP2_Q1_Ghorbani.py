# -*- coding: utf-8 -*-
"""ML_MP2_Q1_Ghorbani.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W3V4FlpTqhgof4tHiL3nXUJyjlDR2ykU

# Q1
Multi-class classification with 2 layer of McCulloch-Pitts neurons. Distinct triangular hatched area with 3 linear classifiers.
"""

# Import libraires
import numpy as np
import matplotlib.pyplot as plt

"""# Part I & II

A) Define Sigmoid, ReLU and ELU function and their derivatives
"""

x = np.linspace(-5,5,100)
sigmoid = []
sigmoid_grad = []
relu = []
relu_grad = []
elu = []
elu_grad = []
alpha = 1

for i in range(len(x)):
  a = 1/(1+np.exp(-x[i]))
  sigmoid.append(a)
  sigmoid_grad.append(a*(1-a))
  relu.append(max(0, x[i]))
  relu_grad.append(1 if x[i] > 0 else 0)
  b= x[i] if x[i] >= 0 else alpha*(np.exp(x[i])-1)
  elu.append(b)
  elu_grad.append(1 if x[i] >= 0 else b+alpha)

"""B) Plot functions"""

plt.figure(figsize=(15, 5))

plt.subplot(1,2,1)
plt.plot(x, sigmoid, linewidth=2, color='blue')
plt.plot(x, sigmoid_grad, linewidth=2, color='red')
plt.legend(['Sigmoid function','Derivative of Sigmoid'])
plt.grid(True)

plt.subplot(1,2,2)
plt.plot(x, relu, linewidth=2, color='blue')
plt.plot(x, relu_grad, linewidth=2, color='red')
plt.legend(['ReLU function','Derivative of ReLU'])
plt.grid(True)

plt.figure(figsize=(15, 5))

plt.subplot(1,2,1)
plt.plot(x, elu, linewidth=2, color='blue')
plt.plot(x, elu_grad, linewidth=2, color='red')
plt.legend(['ELU function','Derivative of ELU'])
plt.grid(True)

plt.subplot(1,2,2)
plt.plot(x, relu, linewidth=2, color='blue')
plt.plot(x, relu_grad, linewidth=2, color='red')
plt.legend(['ReLU function','Derivative of ReLU'])
plt.grid(True)

"""# Part III

A) Define Muculloch & Pitts neuron
"""

class MP_neuron():

  def __init__(self , weights , threshold):
    self.weights = np.array(weights)
    self.threshold = threshold    #define threshold

  def model_step(self , x):
    #define model with threshold
    z = self.weights @ x + self.threshold
    if z >= 0:
        return 1
    else:
        return 0

  def model_sign(self, x):
    #define model with threshold
    z = self.weights @ x +  self.threshold
    if z > 0:
      return 1
    elif z == 0:
      return 0
    elif z < 0:
      return -1

  def model_relu(self, x):
    #define model with threshold
    z = self.weights @ x +  self.threshold
    return max(0,z)

"""B) Define model with Step function as activation function"""

def Area_step(x, y):
  neuron_11 = MP_neuron([-2, -1], 6)
  neuron_12 = MP_neuron([2, -1], -2)
  neuron_13 = MP_neuron([0, 1], 0)
  neuron_21 = MP_neuron([1,1,1],-3)

  a11 = neuron_11.model_step(np.array([x, y]))
  a12 = neuron_12.model_step(np.array([x, y]))
  a13 = neuron_13.model_step(np.array([x, y]))
  a21 = neuron_21.model_step(np.array([a11, a12, a13]))
  return list([a21])

# Generate random data points
num_points = 2000
x_values = np.random.uniform(0, 4, num_points)  # Updated x-axis limits
y_values = np.random.uniform(-1, 3, num_points)  # Updated y-axis limits

# Initialize lists to store data points for different z5 values
red_points = []
green_points = []

for i in range(num_points):
    final_value = Area_step(x_values[i], y_values[i])
    if final_value == [0]:
        red_points.append((x_values[i], y_values[i]))
    else:
        green_points.append((x_values[i], y_values[i]))

# Separate x and y values for red and green points
red_x, red_y = zip(*red_points)
green_x, green_y = zip(*green_points)

# Plotting
plt.figure(figsize=(8, 6))
plt.scatter(red_x, red_y, color='red', label='a21 = 0', sizes = [10,10])
plt.scatter(green_x, green_y, color='green', label='a21 = 1', sizes = [10,10])
plt.xlabel('X values')
plt.ylabel('Y values')
plt.title('Output of neural network, Activation functions = [Layer 1 & 2 = step]')

plt.legend(loc='upper right', bbox_to_anchor=(1.2, 1.0))

plt.plot([2,3],[2,0], color = 'black', linewidth =2)
plt.plot([2,1],[2,0], color = 'black', linewidth =2)
plt.plot([1,3],[0,0], color = 'black', linewidth =2)

"""C) Define model with Sign and ReLU function as activation functions"""

def Area_sign(x, y):
  neuron_11 = MP_neuron([-2, -1], 6)
  neuron_12 = MP_neuron([2, -1], -2)
  neuron_13 = MP_neuron([0, 1], 0)
  neuron_21 = MP_neuron([1,1,1],-1)

  a11 = neuron_11.model_sign(np.array([x, y]))
  a12 = neuron_12.model_sign(np.array([x, y]))
  a13 = neuron_13.model_sign(np.array([x, y]))
  a21 = neuron_21.model_relu(np.array([a11, a12, a13]))
  return list([a21])

# Generate random data points
num_points = 2000
x_values = np.random.uniform(0, 4, num_points)  # Updated x-axis limits
y_values = np.random.uniform(-1, 3, num_points)  # Updated y-axis limits

# Initialize lists to store data points for different z5 values
red_points = []
green_points = []

for i in range(num_points):
    final_value = Area_sign(x_values[i], y_values[i])
    if final_value == [0]:
        red_points.append((x_values[i], y_values[i]))
    else:
        green_points.append((x_values[i], y_values[i]))

# Separate x and y values for red and green points
red_x, red_y = zip(*red_points)
green_x, green_y = zip(*green_points)

# Plotting
plt.figure(figsize=(8, 6))
plt.scatter(red_x, red_y, color='red', label='a21 = 0', sizes = [10,10])
plt.scatter(green_x, green_y, color='green', label='a21 != 0', sizes = [10,10])
plt.xlabel('X values')
plt.ylabel('Y values')
plt.title('Output of neural network, Activation functions: [Layer 1 = sign, Layer 2 = ReLU]')

plt.legend(loc='upper right', bbox_to_anchor=(1.2, 1.0))

plt.plot([2,3],[2,0], color = 'black', linewidth =2)
plt.plot([2,1],[2,0], color = 'black', linewidth =2)
plt.plot([1,3],[0,0], color = 'black', linewidth =2)