# -*- coding: utf-8 -*-
"""ML_FinalExam_Ghorbani.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nXIYZX6tnKxOj8bDFMhlclINOpjtu_ID
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sb
from collections import Counter
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.feature_selection import VarianceThreshold
from sklearn import svm
from sklearn.feature_selection import RFE
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay
from sklearn.metrics import classification_report
from sklearn.decomposition import PCA
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis as LDA
from mpl_toolkits.mplot3d import Axes3D
from sklearn.model_selection import KFold
from sklearn.model_selection import GridSearchCV

!pip install --upgrade --no-cach-dir gdown
! 1iPMl6BrPttJjq7y_DCX7qEMoxxJ20mnO

dataset = pd.read_csv('/content/MJMusicDataset.csv', encoding='ISO-8859-1')
dataset

X = dataset.iloc[:, 3:]
y = dataset.iloc[:, 1]

print(X.shape, y.shape)

"""# Part I

Splitting data
"""

x_train , x_test , y_train , y_test = train_test_split(X, y, test_size = 0.2, random_state = 24)
x_train.shape, x_test.shape, y_train.shape, y_test.shape

"""Countplot"""

plt.rcParams["figure.figsize"] = (15, 5)

plt.subplot(1,2,1)
sb.countplot(data=y_train)
plt.title('Train set')

plt.subplot(1,2,2)
sb.countplot(data=y_test)
plt.title('Test set')

"""Corelation matrix"""

plt.rcParams["figure.figsize"] = (15, 10)
sb.heatmap(X.corr(), annot=False, cmap='Blues');
plt.title('Correlation heatmap');

selector = VarianceThreshold(threshold=30)
selector.fit(x_train)
x_train_new = selector.transform(x_train)
x_test_new = selector.transform(x_test)

print(x_train.shape, x_train_new.shape)
print(x_test.shape, x_test_new.shape)

"""# Part II"""

# Define model
clf_rbf = svm.SVC( kernel='rbf', random_state=24)

# Train model
clf_rbf.fit(x_train_new, y_train)

# Prediction
y_pred_rbf = clf_rbf.predict(x_test_new)

# Accuracy score
clf_rbf.score(x_test_new, y_test)

cm_rbf = confusion_matrix(y_test, y_pred_rbf)
disp_rbf = ConfusionMatrixDisplay(confusion_matrix=cm_rbf)
disp_rbf.plot(cmap='Blues')
plt.title('SVC(kernel = rbf)')

"""# Part III"""

CV = KFold(n_splits=5, shuffle=True, random_state=24)

search_space = {
    'degree':[1,2,3]
    }

fold_no = 1

for i, (train_index, test_index) in enumerate(CV.split(X)):

  clf_grid =  GridSearchCV(clf_rbf, search_space)
  search = clf_rbf.fit(X[train_index], y[train_index])
  print(search.best_params_)
  print('---------------------------------------------------------------------')
  print(f'Training for fold {fold_no}')
  fold_no += 1

"""# Part IV

PCA (2D)
"""

pca = PCA(n_components=2, random_state=24)
pca.fit(x_train_new)
x_train_pca = pca.transform(x_train_new)
x_test_pca = pca.transform(x_test_new)
print(x_train_pca.shape, x_test_pca.shape)

sb.scatterplot(x=x_train_pca[:, 0], y=x_train_pca[:, 1], hue=y_train, palette='Blues', edgecolor='k')
plt.title('PCA')

"""LDA"""

lda = LDA(n_components=3)
lda.fit(x_train_new, y_train)
x_train_lda = lda.transform(x_train_new)
x_test_lda = lda.transform(x_test_new)
print(x_train_lda.shape, x_test_lda.shape)

fig = plt.figure(figsize=(8, 6))
ax = fig.add_subplot(111, projection='3d')

ax.scatter(x_train_lda[:, 0], x_train_lda[:, 1], x_train_lda[:, 2])

plt.title('LDA')
plt.show()